## 성 지키기(백준 BOJ 1236)

<br>

2차원 배열

## 문제

영식이는 직사각형 모양의 성을 가지고 있다. 성의 1층은 몇 명의 경비원에 의해서 보호되고 있다. 영식이는 모든 행과 모든 열에 한 명 이상의 경비원이 있으면 좋겠다고 생각했다.

성의 크기와 경비원이 어디있는지 주어졌을 때, 몇 명의 경비원을 최소로 추가해야 영식이를 만족시키는지 구하는 프로그램을 작성하시오.

<br>

## 입력

첫째 줄에 성의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 성의 상태가 주어진다. 성의 상태는 .은 빈칸, X는 경비원이 있는 칸이다.

<br>

## 출력

첫째 줄에 추가해야 하는 경비원의 최솟값을 출력한다.

<br>

## 예제 입력 1

```
4 4
....
....
....
....
```

## 예제 출력 1

```
4
```

## 예제 입력 2

```
3 5
XX...
.XX..
...XX
```

## 예제 출력 2

```
0
```

## 예제 입력 3

```
5 8
....XXXX
........
XX.X.XX.
........
........
```

## 예제 출력 3

```
3
```

<br>

## 📝 풀어보기

📌 성의 세로 크기 `N`, 성의 가로 크기`M` 을 입력받는다.

N의 값 만큼 반복하면서 M의 크기 내의 값을 입력받는다.

각각의 값 비교를 위해 `cnt1, cnt2` 변수를 생성한다.

``` python
N, M = map(int, input().split())
castle = [list(map(str, input())) for _ in range(N)]
cnt1 = 0
cnt2 = 0
```

<br>

📌 N의 값만큼 반복하면서 castle[n]에 X가 없는 행을 확인한다. 

``` python
for n in range(N): # 세로 
    if "X" not in castle[n]: # n : 0, 1, 2
        cnt1 += 1
```

<br>

📌 M의 값만큼 반복하면서 각 행과 열에 X가 들어있지 않은 행렬의 개수를 구한다.  구한 cnt1과 cnt2중 큰 값을 출력한다.

``` python
for m in range(M): # 가로
    # 각 행과 열마다 X가 들어있지 않는 행, 열의 개수를 구한다
    if "X" not in [castle[n][m] for n in range(N)]: # n :0, 1, 2 m : 0 
        cnt2 += 1  
print(max(cnt1, cnt2))
```

<br>

#### 전체코드

``` python
N, M = map(int, input().split())
castle = [list(map(str, input())) for _ in range(N)]
cnt1 = 0
cnt2 = 0

for n in range(N): # 세로
    if "X" not in castle[n]: # n : 0, 1, 2
        cnt1 += 1

for m in range(M): # 가로
    # 각 행과 열마다 X가 들어있지 않는 행, 열의 개수를 구한다
    if "X" not in [castle[n][m] for n in range(N)]: # n :0, 1, 2 m : 0 
        cnt2 += 1                                   # n :0, 1, 2 m : 1
                                                    # n :0, 1, 2 m : 2
# 그 중 큰 값을 출력 
print(max(cnt1, cnt2))

# n = 세로
# m = 가로 

# [['.', '.', '.'] # [0]: [0, 1, 2]
#  ['.', '.', '.'] # [1]: [0, 1, 2]
#  ['.', '.', '.']]# [2]: [0, 1, 2]
```

